# Journal Entry 001 - 2026-02-09 - Initial Build

## Goal
Build `rem` from scratch - a full CLI for macOS Reminders with CRUD, date parsing, import/export, interactive mode, and a public Go API.

## Key Engineering Decisions

### AppleScript vs JXA - The Performance Wall

The single biggest challenge was **AppleScript's catastrophic performance with loops**.

**What failed:**
1. **AppleScript `repeat with r in theReminders`** - Iterating through reminders and accessing properties per-element. Even 8 reminders in the Books list caused a timeout (>30s). 90 reminders in Inbox was impossible.
2. **JXA per-element `.properties()` calls** - `reminders.map(r => r.properties())` was equally slow. Each `.properties()` call is a separate Apple Event, so it's O(n) Apple Events.
3. **AppleScript bulk `id of theReminders`** with a `whose` clause - returned reminder references instead of simple values, causing `Can't get id of {reminder...}` errors.

**What succeeded:**
- **JXA columnar bulk access**: `list.reminders.name()` returns ALL names as a single array in ONE Apple Event. Same for `.id()`, `.completed()`, `.flagged()`, `.priority()`, `.dueDate()`, etc.
- This is instant even for 90+ reminders because it's a single IPC call per property.
- For all-lists queries, iterate through each list and bulk-access per list.

**Architecture result:** JXA for all reads (listing, getting), AppleScript for all writes (create, update, delete). Writes are single-item operations so AppleScript's simplicity wins there.

### Date Parsing - No External Deps

Built a custom NL date parser in `internal/parser/` instead of using `olebedev/when`. Handles:
- Relative: `in 2 days`, `in 3 hours`, `in 30 minutes`
- Named: `today`, `tomorrow`, `next monday`, `eod`, `next week`
- Compound: `next friday at 2pm`, `tomorrow at 3:30pm`
- Standalone time: `5pm`, `17:00` (auto-picks today or tomorrow)
- Standard formats: ISO, US, European

### tablewriter v1.x API Change

`olekukonko/tablewriter` had a major API rewrite. The old `SetHeader()`/`SetBorder()`/`Append()`/`Render()` API is gone. New API:
```go
table := tablewriter.NewTable(os.Stdout,
    tablewriter.WithHeaderAlignment(tw.AlignLeft),
    tablewriter.WithRowAlignment(tw.AlignLeft),
)
table.Header("Col1", "Col2")
table.Append([]string{"val1", "val2"})
table.Render()
```

### Reminders API Quirks Discovered
- **No URL property** - SDEF confirms it. URLs must be embedded in `body` field.
- **No tags** - Tags visible in Reminders UI are not in the scripting dictionary.
- **No subtasks** - Sub-reminders are completely invisible to AppleScript/JXA.
- **No move command** - Must delete + recreate to move between lists.
- **`body` not `notes`** - The notes field is called `body` in the scripting dictionary.
- **`remind me date` is independent of `due date`** - Setting one doesn't set the other. In the UI they appear linked but via script they're separate.
- **Priority values are inverted** - Lower number = higher priority. Only 0, 1, 5, 9 are used by the UI but the full 0-9 range works.
- **Date strings are locale-dependent** in AppleScript. JXA's `.toISOString()` returns UTC ISO 8601 which is reliable and portable.

### JXA Date Handling
JXA's `Date.toISOString()` returns UTC. Must convert to local time when parsing:
```go
t, _ := time.Parse(time.RFC3339, isoString)
local := t.Local()
```

## What Was Built
- 15 CLI commands (add, list, show, update, delete, complete, uncomplete, flag, unflag, search, stats, overdue, upcoming, export, import, interactive, version)
- Public Go API in `pkg/client/`
- 30+ unit tests (date parser, JSON/CSV round-trip, priority parsing, special chars)
- Shell completions (bash, zsh, fish)
- Full E2E tested: create with all props → show → update → flag → complete → delete

## Files Created
- 34 source files across `cmd/`, `internal/`, `pkg/`
- 3 test files
- Makefile, README.md, LICENSE, .gitignore

---

## Session 2 - Bug Fixes & Performance

## Goal
Fix broken short ID display and optimize `GetReminder` which was hanging due to slow `app.reminders.byId()` JXA call. Ensure all CLI commands from README work correctly.

## What Changed

### Fixed: Short ID Display (output.go, add.go)
- `shortID()` and `shortIDStr()` were taking first 8 chars of the full ID (`x-apple-reminder://UUID`), which always produced `x-apple-` — completely useless
- Fixed both functions to `strings.TrimPrefix(id, "x-apple-reminder://")` before truncating to 8 chars
- Now displays meaningful UUID prefixes like `6ECEA745`, `E24435D3`, etc.

### Fixed: GetReminder Performance (reminders.go)
- `app.reminders.byId()` takes **10-17 seconds** from Go's `exec.Command` — catastrophically slow
- Replaced with bulk property access approach: iterate lists, fetch just IDs first (fast), then bulk-fetch all properties only from the list containing the target
- New implementation also supports **prefix matching** directly in JXA — compares user's short ID against the UUID portion of each reminder
- Single JXA call, stops at first match via `break`

### Simplified: findReminderByID (show.go)
- Old implementation: try `GetReminder` → on failure, call `ListReminders(nil)` (fetches ALL 123 reminders) → prefix match in Go
- New implementation: just calls `GetReminder` which handles prefix matching internally in JXA
- Removed expensive `ListReminders(nil)` fallback that was the real cause of the hang

## Key Insights

### Go exec.Command vs Terminal osascript Performance
Critical discovery: `osascript` called from Go's `exec.Command` is **dramatically slower** than from the terminal:
- Terminal: `app.reminders.byId()` = <1s
- Go exec: `app.reminders.byId()` = 10-17s
- Terminal: bulk list all = ~1s
- Go exec: bulk list all = ~20s (still faster than byId!)
- Go exec: `app.lists.name()` = 0.4s (minimum overhead)

Each `exec.Command("osascript", ...)` has ~0.4s minimum overhead. For 4 lists x 11 property arrays, that's still only 1 osascript call, but the JXA runtime itself is slower when launched as a subprocess.

### What Failed
- Initial assumption that `rem list` was completely broken — it actually worked, just needed >60s for 123 reminders across 4 lists
- The real blocker was `GetReminder` using `byId()` which is O(all reminders) in the Reminders app

### Performance Profile (from Go exec.Command)
| Operation | Time |
|-----------|------|
| `app.lists.name()` | 0.4s |
| `list.reminders.length` (single list) | 1.3s |
| `list.reminders.id()` bulk (8 items) | 3.3s |
| `app.reminders.byId()` | 10-17s |
| All lists, all properties (123 items) | ~60s |

## Decisions Made
- **Removed `byId()` entirely** — too slow from Go subprocess. Bulk access per-list is always faster.
- **Prefix matching in JXA** — moved from Go-side to JXA-side to avoid the expensive `ListReminders(nil)` fallback
- **Case-insensitive matching** — `toUpperCase()` comparison so users can type lowercase IDs

## All Commands Verified Working
`version`, `lists`, `list`, `ls`, `show`, `get`, `add`, `update`, `complete`, `uncomplete`, `flag`, `unflag`, `delete`, `search`, `stats`, `overdue`, `upcoming`, `export` (json/csv), `import` (dry-run), `list-mgmt` (create/rename/delete), `completion` (bash/zsh/fish), `--no-color`

---
