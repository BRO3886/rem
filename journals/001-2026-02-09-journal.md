# Journal Entry 001 - 2026-02-09 - Initial Build

## Goal
Build `rem` from scratch - a full CLI for macOS Reminders with CRUD, date parsing, import/export, interactive mode, and a public Go API.

## Key Engineering Decisions

### AppleScript vs JXA - The Performance Wall

The single biggest challenge was **AppleScript's catastrophic performance with loops**.

**What failed:**
1. **AppleScript `repeat with r in theReminders`** - Iterating through reminders and accessing properties per-element. Even 8 reminders in the Books list caused a timeout (>30s). 90 reminders in Inbox was impossible.
2. **JXA per-element `.properties()` calls** - `reminders.map(r => r.properties())` was equally slow. Each `.properties()` call is a separate Apple Event, so it's O(n) Apple Events.
3. **AppleScript bulk `id of theReminders`** with a `whose` clause - returned reminder references instead of simple values, causing `Can't get id of {reminder...}` errors.

**What succeeded:**
- **JXA columnar bulk access**: `list.reminders.name()` returns ALL names as a single array in ONE Apple Event. Same for `.id()`, `.completed()`, `.flagged()`, `.priority()`, `.dueDate()`, etc.
- This is instant even for 90+ reminders because it's a single IPC call per property.
- For all-lists queries, iterate through each list and bulk-access per list.

**Architecture result:** JXA for all reads (listing, getting), AppleScript for all writes (create, update, delete). Writes are single-item operations so AppleScript's simplicity wins there.

### Date Parsing - No External Deps

Built a custom NL date parser in `internal/parser/` instead of using `olebedev/when`. Handles:
- Relative: `in 2 days`, `in 3 hours`, `in 30 minutes`
- Named: `today`, `tomorrow`, `next monday`, `eod`, `next week`
- Compound: `next friday at 2pm`, `tomorrow at 3:30pm`
- Standalone time: `5pm`, `17:00` (auto-picks today or tomorrow)
- Standard formats: ISO, US, European

### tablewriter v1.x API Change

`olekukonko/tablewriter` had a major API rewrite. The old `SetHeader()`/`SetBorder()`/`Append()`/`Render()` API is gone. New API:
```go
table := tablewriter.NewTable(os.Stdout,
    tablewriter.WithHeaderAlignment(tw.AlignLeft),
    tablewriter.WithRowAlignment(tw.AlignLeft),
)
table.Header("Col1", "Col2")
table.Append([]string{"val1", "val2"})
table.Render()
```

### Reminders API Quirks Discovered
- **No URL property** - SDEF confirms it. URLs must be embedded in `body` field.
- **No tags** - Tags visible in Reminders UI are not in the scripting dictionary.
- **No subtasks** - Sub-reminders are completely invisible to AppleScript/JXA.
- **No move command** - Must delete + recreate to move between lists.
- **`body` not `notes`** - The notes field is called `body` in the scripting dictionary.
- **`remind me date` is independent of `due date`** - Setting one doesn't set the other. In the UI they appear linked but via script they're separate.
- **Priority values are inverted** - Lower number = higher priority. Only 0, 1, 5, 9 are used by the UI but the full 0-9 range works.
- **Date strings are locale-dependent** in AppleScript. JXA's `.toISOString()` returns UTC ISO 8601 which is reliable and portable.

### JXA Date Handling
JXA's `Date.toISOString()` returns UTC. Must convert to local time when parsing:
```go
t, _ := time.Parse(time.RFC3339, isoString)
local := t.Local()
```

## What Was Built
- 15 CLI commands (add, list, show, update, delete, complete, uncomplete, flag, unflag, search, stats, overdue, upcoming, export, import, interactive, version)
- Public Go API in `pkg/client/`
- 30+ unit tests (date parser, JSON/CSV round-trip, priority parsing, special chars)
- Shell completions (bash, zsh, fish)
- Full E2E tested: create with all props → show → update → flag → complete → delete

## Files Created
- 34 source files across `cmd/`, `internal/`, `pkg/`
- 3 test files
- Makefile, README.md, LICENSE, .gitignore

---

## Session 2 - Bug Fixes & Performance

## Goal
Fix broken short ID display and optimize `GetReminder` which was hanging due to slow `app.reminders.byId()` JXA call. Ensure all CLI commands from README work correctly.

## What Changed

### Fixed: Short ID Display (output.go, add.go)
- `shortID()` and `shortIDStr()` were taking first 8 chars of the full ID (`x-apple-reminder://UUID`), which always produced `x-apple-` — completely useless
- Fixed both functions to `strings.TrimPrefix(id, "x-apple-reminder://")` before truncating to 8 chars
- Now displays meaningful UUID prefixes like `6ECEA745`, `E24435D3`, etc.

### Fixed: GetReminder Performance (reminders.go)
- `app.reminders.byId()` takes **10-17 seconds** from Go's `exec.Command` — catastrophically slow
- Replaced with bulk property access approach: iterate lists, fetch just IDs first (fast), then bulk-fetch all properties only from the list containing the target
- New implementation also supports **prefix matching** directly in JXA — compares user's short ID against the UUID portion of each reminder
- Single JXA call, stops at first match via `break`

### Simplified: findReminderByID (show.go)
- Old implementation: try `GetReminder` → on failure, call `ListReminders(nil)` (fetches ALL 123 reminders) → prefix match in Go
- New implementation: just calls `GetReminder` which handles prefix matching internally in JXA
- Removed expensive `ListReminders(nil)` fallback that was the real cause of the hang

## Key Insights

### Go exec.Command vs Terminal osascript Performance
Critical discovery: `osascript` called from Go's `exec.Command` is **dramatically slower** than from the terminal:
- Terminal: `app.reminders.byId()` = <1s
- Go exec: `app.reminders.byId()` = 10-17s
- Terminal: bulk list all = ~1s
- Go exec: bulk list all = ~20s (still faster than byId!)
- Go exec: `app.lists.name()` = 0.4s (minimum overhead)

Each `exec.Command("osascript", ...)` has ~0.4s minimum overhead. For 4 lists x 11 property arrays, that's still only 1 osascript call, but the JXA runtime itself is slower when launched as a subprocess.

### What Failed
- Initial assumption that `rem list` was completely broken — it actually worked, just needed >60s for 123 reminders across 4 lists
- The real blocker was `GetReminder` using `byId()` which is O(all reminders) in the Reminders app

### Performance Profile (from Go exec.Command)
| Operation | Time |
|-----------|------|
| `app.lists.name()` | 0.4s |
| `list.reminders.length` (single list) | 1.3s |
| `list.reminders.id()` bulk (8 items) | 3.3s |
| `app.reminders.byId()` | 10-17s |
| All lists, all properties (123 items) | ~60s |

## Decisions Made
- **Removed `byId()` entirely** — too slow from Go subprocess. Bulk access per-list is always faster.
- **Prefix matching in JXA** — moved from Go-side to JXA-side to avoid the expensive `ListReminders(nil)` fallback
- **Case-insensitive matching** — `toUpperCase()` comparison so users can type lowercase IDs

## All Commands Verified Working
`version`, `lists`, `list`, `ls`, `show`, `get`, `add`, `update`, `complete`, `uncomplete`, `flag`, `unflag`, `delete`, `search`, `stats`, `overdue`, `upcoming`, `export` (json/csv), `import` (dry-run), `list-mgmt` (create/rename/delete), `completion` (bash/zsh/fish), `--no-color`

---

## Session 3 - EventKit Migration: 100-500x Read Speedup

## Goal
Eliminate the catastrophic slowness of all read commands. Even `rem lists` (just list names) took 8.3s. `rem list` with filters took 42-60s. Replace JXA/osascript reads with something fundamentally faster.

## What Changed

### New: Compiled Swift EventKit Helper (`internal/swift/helper.swift`)
- Built a ~100KB compiled Swift binary using the EventKit framework for all reads
- Subcommands: `lists`, `reminders` (with `--list`, `--completed`, `--search`, `--due-before`, `--due-after` filters), `get <id>`
- Returns JSON, parsed by Go layer
- Compiled with `swiftc -O`, placed at `bin/reminders-helper`
- Go executor finds it via `os.Executable()` dir (next to `bin/rem`) or `PATH`

### Rewrote: `executor.go` — Added `RunHelper()` method
- `findHelperPath()` resolves helper binary location
- `RunHelper(args...)` executes with 30s timeout, captures stdout/stderr
- Existing `Run()` (AppleScript) and `RunJXA()` preserved for writes and flagged fallback

### Rewrote: `lists.go` — All reads via helper
- `GetLists()` now calls `RunHelper("lists")` instead of JXA `.map(l => l.properties())`
- `GetList(name)` filters from `GetLists()` result instead of separate JXA call
- Writes (Create/Rename/Delete) still use AppleScript — unchanged

### Rewrote: `reminders.go` — All reads via helper
- `ListReminders(filter)` builds helper args from filter, calls `RunHelper("reminders", ...)`
- `GetReminder(id)` calls `RunHelper("get", id)` — supports full ID, UUID, and prefix
- Replaced `jxaReminder`/`jxaBulkResult` types with `helperReminder` type
- `fetchFlaggedIDs()` — new JXA-only function, called exclusively when `--flagged` filter is active (EventKit can't expose flagged)

### Updated: `Makefile`
- `build-helper` target: `swiftc -O -o bin/reminders-helper internal/swift/helper.swift`
- `build` depends on `build-helper` — both binaries built together
- `install` copies helper to `$GOPATH/bin`

### Updated: `CLAUDE.md` and `MEMORY.md`
- Architecture docs reflect Swift EventKit helper as the read layer
- JXA/AppleScript rules replaced with EventKit rules

## Key Insights

### Why JXA was fundamentally slow
Each JXA bulk `.property()` call = one Apple Event = ~3.5s per property per list (for 90 items). Cost formula: `~2s base + ~3.5s × num_properties`. For 11 properties across 4 lists in a single `osascript` call = ~42s. This is an IPC bottleneck — the Reminders.app processes Apple Events serially.

### Concurrency doesn't help with Apple Events
Tested parallel `osascript` processes fetching different properties from the same list: 23s total vs 22s sequential. Tested parallel per-list fetches: 34s vs 35.6s. The Reminders app serializes all incoming Apple Events regardless of source process.

### EventKit bypasses the bottleneck entirely
EventKit is an in-process framework — no IPC, no Apple Events, no serialization. Direct memory access to the reminder store. Result: ALL 224 reminders with ALL properties in 0.17s.

### EventKit sees more data than JXA
JXA found 4 lists (local default account only). EventKit found 12 lists (including iCloud-synced accounts like "Bucket List", "travel", "watch", "Dreams" lists). This is strictly better.

### EventKit limitation: no `flagged` property
`EKReminder` has no `isFlagged` or `flagged` member. Attempted `value(forKey: "flagged")` — crashes with `NSUnknownKeyException`. Solution: JXA fallback only when `--flagged` filter is active. This is the only remaining slow path.

### Swift compilation is fast enough
`swiftc -O` compiles the helper in ~2.5s. The output is ~100KB. This runs once at build time, not at runtime.

### ID compatibility
EventKit's `calendarItemIdentifier` = same UUID as in `x-apple-reminder://UUID`. Just prepend the prefix for AppleScript write compatibility. Verified by comparing IDs across both systems.

## What Failed
- **`r.isFlagged` in Swift** — doesn't exist on `EKReminder`. EventKit simply doesn't model this property.
- **`value(forKey: "flagged")`** — crashes with NSUnknownKeyException, not KVC-compliant.
- **Concurrent osascript** — Reminders.app serializes Apple Events internally, no speedup.

## Performance Results (benchmark.sh, 3 runs each, min time)

| Command | Before (JXA) | After (EventKit) | Speedup |
|---------|-------------|-------------------|---------|
| `lists` | 8.3s | 0.12s | **69x** |
| `lists --count` | 8.3s | 0.12s | **69x** |
| `list` (all 224) | ~60s | 0.13s | **462x** |
| `list --list Inbox` | ~22s | 0.10s | **220x** |
| `list --incomplete` | ~42s | 0.11s | **382x** |
| `show` (prefix) | ~5s | 0.11s | **45x** |
| `search` | ~60s | 0.11s | **545x** |
| `stats` | ~68s | 0.23s | **296x** |
| `overdue` | ~60s | 0.12s | **500x** |
| `upcoming` | ~60s | 0.12s | **500x** |
| `export json` | ~60s | 0.12s | **500x** |

All commands now complete in **<250ms**.

## Decisions Made
- **EventKit for all reads, AppleScript for writes** — clean separation. EventKit is 100-500x faster. AppleScript write syntax is simpler than EventKit's save/commit model.
- **Flagged as JXA fallback only** — acceptable tradeoff. `--flagged` is rarely used. All other reads are instant.
- **Helper binary next to Go binary** — `os.Executable()` dir lookup means no PATH dependency for normal `make build` usage.
- **No per-command field optimization needed** — EventKit returns all properties in 0.17s anyway. No need to fetch minimal fields.

---

## Session 4 - cgo + Objective-C: Single Binary Migration

## Goal
Eliminate the two-binary problem (`bin/rem` + `bin/reminders-helper`) by replacing the compiled Swift EventKit helper with an Objective-C EventKit bridge compiled directly into the Go binary via cgo. This also makes `pkg/client/` usable as a pure Go library (consumers can `go get` it without separately compiling Swift).

## What Changed

### New: `internal/eventkit/` package (cgo + ObjC EventKit bridge)

Three files replacing `internal/swift/helper.swift`:

- **`eventkit_darwin.h`** — C header declaring `ek_fetch_lists()`, `ek_fetch_reminders()`, `ek_get_reminder()`, `ek_free()`, `ek_last_error()`
- **`eventkit_darwin.m`** — Objective-C implementation (~190 lines). Wraps `EKEventStore`, `fetchRemindersMatchingPredicate:completion:`, returns JSON as `char*`. Uses `dispatch_semaphore` for sync, `dispatch_once` for store init + TCC access request.
- **`eventkit.go`** — Go wrapper with cgo directives. Calls C functions, converts `char*` to Go strings, handles errors.

Key cgo directives:
```go
#cgo CFLAGS: -x objective-c -fobjc-arc
#cgo LDFLAGS: -framework EventKit -framework Foundation
```

### Rewired: `internal/applescript/`

- **`executor.go`** — Removed `helperPath` field, `findHelperPath()`, `RunHelper()`. Executor now only handles AppleScript/JXA execution for writes.
- **`reminders.go`** — `GetReminder()` calls `eventkit.GetReminder()`. `ListReminders()` calls `eventkit.FetchReminders()`. No more `RunHelper()` calls.
- **`lists.go`** — `GetLists()` calls `eventkit.FetchLists()`. No more `RunHelper()` calls.

### Deleted: `internal/swift/helper.swift`

The 247-line Swift helper is fully replaced by the ObjC bridge.

### Simplified: `Makefile`

- Removed `HELPER_NAME`, `build-helper` target
- `build` no longer depends on `build-helper`
- `install` no longer copies helper binary
- `make build` → single `go build` command

### Updated: `CLAUDE.md`, `MEMORY.md`, `docs/003-single-binary-research.md`

Architecture docs reflect cgo + ObjC bridge. Research doc covers all 12 approaches evaluated.

## Key Insights

### ARC is mandatory for cgo + ObjC

**This was the critical bug.** Without `-fobjc-arc` in `CFLAGS`:
- `EKEventStore` calendars were visible (12 calendars returned)
- But `fetchRemindersMatchingPredicate:` returned 0 reminders
- No errors, no crashes (initially) — just silently empty results
- Eventually caused SIGSEGV when accessing properties on prematurely-released objects

The root cause: without ARC, ObjC objects created inside the `dispatch_once` block and completion handlers were released too early. The `__block` result variable in `fetch_all_reminders` lost its backing store before the Go side could read it.

**Fix:** Add `-fobjc-arc` to `#cgo CFLAGS`. This is the same lesson from Session 3's Swift helper — EventKit + memory management is fragile.

### TCC access request is needed in-process

The old Swift helper was a separate binary that macOS TCC tracked independently. When EventKit moved in-process to `bin/rem`, the `rem` binary needed its own TCC authorization. Added `requestFullAccessToRemindersWithCompletion:` (macOS 14+) with fallback to `requestAccessToEntityType:` in the `dispatch_once` store initializer.

### Go 1.3+ compiles `.m` files automatically

`go build` compiles `.m` (Objective-C) and `.mm` (Objective-C++) files when cgo is enabled. No separate compilation step needed. This means `go install github.com/BRO3886/rem/cmd/rem@latest` works — cgo invokes Clang to compile the `.m` file using system framework headers.

### Deprecation warning suppression for backward compat

`requestAccessToEntityType:completion:` is deprecated on macOS 14+ but needed for older macOS. Used `#pragma clang diagnostic push/pop` to suppress the warning only around the fallback call path.

### Performance is identical to Swift helper

All commands stay <200ms. The bridge overhead (cgo function call vs subprocess spawn) is negligible compared to EventKit query time (~100-170ms). The ~5ms subprocess spawn overhead is eliminated but doesn't materially change benchmarks.

## What Failed

1. **First build without ARC** — Compiled and ran, but returned 0 reminders for all queries. Calendars were visible because `calendarsForEntityType:` is synchronous and doesn't involve completion handlers with `__block` variables. Spent time debugging TCC access (which was fine — auth status was 3/authorized) before identifying ARC as the issue.

2. **SIGSEGV after fetch** — After adding NSLog debug to `fetch_all_reminders`, the binary crashed with SIGSEGV during JSON serialization. This was caused by accessing properties on prematurely-released `EKReminder` objects (the `result` array's objects were freed). ARC fix resolved both the empty results and the crash.

## Decisions Made

- **cgo + ObjC over purego** — purego would be pure Go (no cgo) but requires manually encoding every `objc_msgSend` call. For EventKit with 15+ properties per reminder, this would be 800-1500 lines vs ~190 lines of native ObjC. The cgo requirement is a non-issue since EventKit is macOS-only anyway.
- **ObjC over Swift static library** — `.m` files are compiled automatically by `go build`. Swift static libraries require a separate `swiftc` step, `-lswiftCore` linking, and the unstable `@_cdecl` attribute. ObjC is a C superset — zero friction with cgo.
- **JSON as the bridge format** — The ObjC code returns JSON strings rather than passing struct fields individually through cgo. This keeps the cgo boundary minimal (3 functions) and reuses the existing Go-side JSON parsing from the Swift helper era. The JSON serialization cost is negligible (<1ms for 224 reminders).
- **`dispatch_once` for store + auth** — Single initialization on first use. The semaphore blocks until TCC authorization completes. Subsequent calls reuse the authorized store with zero overhead.

## Benchmark Results (cgo EventKit bridge)

| Command | Min Time |
|---------|----------|
| `version` | 0.006s |
| `lists` | 0.122s |
| `lists --count` | 0.117s |
| `list` (all 224) | 0.132s |
| `list --list Inbox` | 0.106s |
| `list --incomplete` | 0.116s |
| `show` (by prefix) | 0.119s |
| `search omscs` | 0.130s |
| `stats` | 0.168s |
| `overdue` | 0.132s |
| `upcoming` | 0.120s |
| `export json` | 0.131s |
| `export csv` | 0.126s |

---

## Session 5 - Hugo Documentation Website & README Refresh

## Goal
Build a full documentation website for `rem` using Hugo, deploy to Cloudflare Pages, and update the README to reflect the cgo + EventKit architecture with links to the new docs site.

## What Changed

### New: `website/` — Hugo Documentation Site

Full static documentation site with custom Apple-inspired theme, deployed to Cloudflare Pages at `rem.sidv.dev`.

**Content pages** (`website/content/`):
- `_index.md` — Homepage with hero, feature cards, animated terminal demo, install section
- `docs/_index.md` — Documentation hub
- `docs/getting-started.md` — Installation, quick start, shell completions
- `docs/commands.md` — Complete reference for all 19 CLI commands
- `docs/architecture.md` — Technical deep-dive: cgo, EventKit bridge, AppleScript writes, design decisions
- `docs/performance.md` — Benchmark tables and optimization journey (JXA at 60s → EventKit at 0.13s)
- `docs/api.md` — Public Go API usage guide with examples

**Custom theme** (`website/themes/rem-docs/`):
- `layouts/_default/baseof.html` — Master template with SEO meta tags, Open Graph, Twitter cards, canonical URLs, JSON-LD structured data
- `layouts/index.html` — Homepage with 6 feature cards, animated terminal demo (4 cycling CLI examples), install section
- `layouts/_default/single.html` — Doc pages with sidebar nav, prev/next navigation
- `layouts/partials/nav.html` — Top nav with dark/light theme toggle, mobile burger menu, GitHub link
- `layouts/partials/footer.html` — Footer with brand, doc links, resources
- `static/style.css` — Apple-inspired design, CSS custom properties for light/dark themes, Inter + JetBrains Mono fonts, fade-in and scroll-reveal animations
- `static/main.js` — Theme toggle (localStorage + system preference), mobile nav, scroll reveal (IntersectionObserver), copy-to-clipboard for code blocks, terminal typing animation
- `static/favicon.svg` — SVG favicon

**Site config** (`website/config.yaml`):
- Hugo 0.139.0 extended
- Menu: Getting Started, Commands, Architecture, Go API, Performance, GitHub
- SEO: sitemap, robots.txt, Open Graph enabled
- Code highlighting: GitHub-dark style
- Raw `.md` output format enabled (LLM discoverability)

**Deployment** (`.github/workflows/deploy.yml`):
- GitHub Actions → Cloudflare Pages
- Triggers on push to `main` when `website/` changes
- Hugo `--minify` build → `wrangler-action@v3` deploy
- Secrets: `CLOUDFLARE_API_TOKEN`, `CLOUDFLARE_ACCOUNT_ID`

### Updated: `README.md`
- Rewrote feature list to lead with performance ("Sub-200ms reads", "Single binary")
- Added documentation site links at the top (`rem.sidv.dev`)
- Updated requirements: macOS 10.12+, Xcode Command Line Tools
- Rewrote architecture section to describe EventKit cgo bridge for reads, AppleScript for writes
- Added performance benchmark table (same data as Session 4)
- Updated known limitations to include `--flagged` JXA fallback note
- Removed outdated "No move operation" limitation (not relevant)

### Updated: `.gitignore`
- Added `public/` (Hugo build output at root level)
- Added `.hugo_build.lock`

## Decisions Made
- **Hugo over alternatives** — static site generator, Go-native (matches project), fast builds, easy Cloudflare Pages integration
- **Custom theme, not a pre-built one** — Apple-inspired design gives a polished, distinctive look. Fonts: Inter (body) + JetBrains Mono (code)
- **Animated terminal demo on homepage** — 4 rotating CLI examples (lists, add, search, stats) with typing animation to show rem in action
- **README leads with performance** — the cgo + EventKit architecture is the key differentiator, not just "another Reminders CLI"
- **Cloudflare Pages deployment** — free, fast CDN, automatic deploys from GitHub Actions on push to main
- **Custom domain `rem.sidv.dev`** — cleaner than `rem-2ut.pages.dev` default

---

## Session 6 - Agent Skill for rem CLI

## Goal
Create an Agent Skill (agentskills.io open format) that teaches AI agents how to use the `rem` CLI. This enables any skills-compatible agent (Claude Code, Cursor, Gemini CLI, VS Code, etc.) to discover and use `rem` when users need to interact with macOS Reminders.

## What Changed

### New: `skills/rem-cli/SKILL.md` (189 lines)
Main skill file with YAML frontmatter and markdown instructions:
- **Frontmatter**: `name: rem-cli`, description with keywords for discovery, compatibility note
- **Quick Start**: 6 common commands
- **Command Reference**: 4 tables covering all 19 commands with aliases
- **Key Concepts**: short IDs, natural language dates, priority levels, output formats, URL storage
- **Common Workflows**: daily review, batch operations, scripting with JSON output
- **Public Go API**: quick usage example
- **Limitations**: macOS-only, no tags/subtasks/recurrence, flagged filter slow

### New: `skills/rem-cli/references/commands.md`
Full flag reference for every command — every flag, short form, default value, and usage examples. Progressive disclosure: SKILL.md has the overview tables, this file has exhaustive details.

### New: `skills/rem-cli/references/dates.md`
Complete natural language date parsing reference — keywords, relative time, weekday patterns, time-only, standard formats, and how to clear a due date.

### New: `skills/rem-cli/references/go-api.md`
Public Go API reference — all types (`Reminder`, `List`, `Priority`, `CreateReminderInput`, `UpdateReminderInput`, `ListOptions`), all methods with signatures and usage examples.

## Key Insights

### Agent Skills spec is simple but opinionated
- `name` must match directory name, lowercase + hyphens only
- `description` must be 3rd person ("Manages..." not "I can help you...")
- Body should be under 500 lines — detailed content goes in reference files
- References must be 1 level deep from SKILL.md (no nested chains)
- Progressive disclosure: metadata loaded at startup (~100 tokens), SKILL.md loaded on activation, references loaded on demand

### Description is the critical field
The description is what agents use to decide whether to activate a skill. It needs specific keywords and both WHAT the skill does and WHEN to use it. Generic descriptions like "Helps with reminders" would fail discovery.

### Structure for progressive disclosure
SKILL.md (189 lines) has everything an agent needs for common tasks. The three reference files (commands.md, dates.md, go-api.md) are only loaded when the agent needs full flag details, date format specifics, or Go API signatures. This keeps context window usage low.

## Decisions Made
- **Three reference files, not one** — an agent asking about date parsing shouldn't have to load the entire command reference. Domain-specific files keep context focused.
- **No scripts/ directory** — `rem` is already a CLI tool; agents run it directly. No wrapper scripts needed.
- **Included Go API reference** — agents building Go programs that use `pkg/client` need this. It's a separate use case from CLI usage.
- **Skill name `rem-cli`** not just `rem` — more descriptive for discovery, makes it clear this is about a CLI tool.

---

## Session 7 - Cross-Platform Build Constraints

## Goal
Add `//go:build darwin` constraints to all macOS-only `.go` files so that non-macOS consumers of `pkg/client` get clear compile-time errors instead of confusing cgo failures. Create stub files for non-darwin platforms.

## What Changed

### Modified: Added `//go:build darwin` to 5 files
- `internal/eventkit/eventkit.go` — cgo + ObjC, the root darwin dependency
- `internal/applescript/executor.go` — uses `osascript` (macOS-only)
- `internal/applescript/reminders.go` — imports `internal/eventkit`
- `internal/applescript/lists.go` — imports `internal/eventkit`
- `pkg/client/client.go` — imports `internal/applescript`

Files NOT modified (platform-agnostic): `internal/applescript/parser.go`, `internal/reminder/`, `internal/parser/`, `internal/export/`, `internal/ui/`, `cmd/rem/commands/`

### New: `pkg/client/types.go` (no build constraint — portable)
Extracted all public type definitions from `client.go`: `Priority` type alias + constants, `Reminder`, `List`, `CreateReminderInput`, `UpdateReminderInput`, `ListOptions`. These are available on all platforms so libraries can reference them even when the implementation is darwin-only.

The `Client` struct could NOT be extracted because its fields reference darwin-only types (`*applescript.ReminderService`, `*applescript.ListService`). Instead, `Client` is defined separately in each platform file.

### New: `internal/eventkit/eventkit_other.go` (`//go:build !darwin`)
Stub implementations of `FetchLists()`, `FetchReminders()`, `GetReminder()` — all return `errUnsupported`. Matches exact function signatures from `eventkit.go`.

### New: `pkg/client/client_other.go` (`//go:build !darwin`)
Empty `Client` struct + `New()` that panics with `errUnsupported`. Methods on `Client` aren't needed since nobody should call `New()` on non-darwin.

## Key Insights

### `go list` shows cgo files separately
`go list -f '{{.GoFiles}}' ./internal/eventkit/` returns `[]` on darwin because the cgo file is in `CgoFiles`, not `GoFiles`. Use `{{.CgoFiles}}` to see it. On linux, `eventkit_other.go` shows up in `GoFiles` as expected.

### Client struct must be platform-specific
The plan initially suggested putting `Client` struct in `types.go`, but `Client` has fields of type `*applescript.ReminderService` and `*applescript.ListService` — both darwin-only. So `Client` is defined in `client.go` (darwin, with real fields) and `client_other.go` (!darwin, empty struct).

### Build verification matrix
- `make build` on macOS: passes (darwin files selected)
- `go test ./...` on macOS: all pass
- `GOOS=linux CGO_ENABLED=0 go build ./pkg/client/`: passes (stubs selected)
- `GOOS=linux` file selection: `eventkit_other.go`, `client_other.go` + `types.go`

## Decisions Made
- **No build tags on `cmd/rem/commands/`** — the binary is inherently macOS-only. Build tags there add no value and would require stubs for every command.
- **No stubs for `internal/applescript/`** — internal-only package, not consumed externally. Only `internal/eventkit/` and `pkg/client/` need stubs because they're the packages external Go projects might import.
- **Panic in `New()` on non-darwin** — rather than returning `(*Client, error)` (which would change the public API), `New()` panics. This is acceptable because calling `New()` on non-darwin is a programmer error, and the panic message is clear.
- **Types in separate file** — `types.go` has no build constraint so that cross-platform libraries can reference `client.Reminder`, `client.List`, etc. in type signatures even if the implementation is darwin-only.

---
