# Journal Entry 001 - 2026-02-09 - Initial Build

## Goal
Build `rem` from scratch - a full CLI for macOS Reminders with CRUD, date parsing, import/export, interactive mode, and a public Go API.

## Key Engineering Decisions

### AppleScript vs JXA - The Performance Wall

The single biggest challenge was **AppleScript's catastrophic performance with loops**.

**What failed:**
1. **AppleScript `repeat with r in theReminders`** - Iterating through reminders and accessing properties per-element. Even 8 reminders in the Books list caused a timeout (>30s). 90 reminders in Inbox was impossible.
2. **JXA per-element `.properties()` calls** - `reminders.map(r => r.properties())` was equally slow. Each `.properties()` call is a separate Apple Event, so it's O(n) Apple Events.
3. **AppleScript bulk `id of theReminders`** with a `whose` clause - returned reminder references instead of simple values, causing `Can't get id of {reminder...}` errors.

**What succeeded:**
- **JXA columnar bulk access**: `list.reminders.name()` returns ALL names as a single array in ONE Apple Event. Same for `.id()`, `.completed()`, `.flagged()`, `.priority()`, `.dueDate()`, etc.
- This is instant even for 90+ reminders because it's a single IPC call per property.
- For all-lists queries, iterate through each list and bulk-access per list.

**Architecture result:** JXA for all reads (listing, getting), AppleScript for all writes (create, update, delete). Writes are single-item operations so AppleScript's simplicity wins there.

### Date Parsing - No External Deps

Built a custom NL date parser in `internal/parser/` instead of using `olebedev/when`. Handles:
- Relative: `in 2 days`, `in 3 hours`, `in 30 minutes`
- Named: `today`, `tomorrow`, `next monday`, `eod`, `next week`
- Compound: `next friday at 2pm`, `tomorrow at 3:30pm`
- Standalone time: `5pm`, `17:00` (auto-picks today or tomorrow)
- Standard formats: ISO, US, European

### tablewriter v1.x API Change

`olekukonko/tablewriter` had a major API rewrite. The old `SetHeader()`/`SetBorder()`/`Append()`/`Render()` API is gone. New API:
```go
table := tablewriter.NewTable(os.Stdout,
    tablewriter.WithHeaderAlignment(tw.AlignLeft),
    tablewriter.WithRowAlignment(tw.AlignLeft),
)
table.Header("Col1", "Col2")
table.Append([]string{"val1", "val2"})
table.Render()
```

### Reminders API Quirks Discovered
- **No URL property** - SDEF confirms it. URLs must be embedded in `body` field.
- **No tags** - Tags visible in Reminders UI are not in the scripting dictionary.
- **No subtasks** - Sub-reminders are completely invisible to AppleScript/JXA.
- **No move command** - Must delete + recreate to move between lists.
- **`body` not `notes`** - The notes field is called `body` in the scripting dictionary.
- **`remind me date` is independent of `due date`** - Setting one doesn't set the other. In the UI they appear linked but via script they're separate.
- **Priority values are inverted** - Lower number = higher priority. Only 0, 1, 5, 9 are used by the UI but the full 0-9 range works.
- **Date strings are locale-dependent** in AppleScript. JXA's `.toISOString()` returns UTC ISO 8601 which is reliable and portable.

### JXA Date Handling
JXA's `Date.toISOString()` returns UTC. Must convert to local time when parsing:
```go
t, _ := time.Parse(time.RFC3339, isoString)
local := t.Local()
```

## What Was Built
- 15 CLI commands (add, list, show, update, delete, complete, uncomplete, flag, unflag, search, stats, overdue, upcoming, export, import, interactive, version)
- Public Go API in `pkg/client/`
- 30+ unit tests (date parser, JSON/CSV round-trip, priority parsing, special chars)
- Shell completions (bash, zsh, fish)
- Full E2E tested: create with all props → show → update → flag → complete → delete

## Files Created
- 34 source files across `cmd/`, `internal/`, `pkg/`
- 3 test files
- Makefile, README.md, LICENSE, .gitignore

---

## Session 2 - Bug Fixes & Performance

## Goal
Fix broken short ID display and optimize `GetReminder` which was hanging due to slow `app.reminders.byId()` JXA call. Ensure all CLI commands from README work correctly.

## What Changed

### Fixed: Short ID Display (output.go, add.go)
- `shortID()` and `shortIDStr()` were taking first 8 chars of the full ID (`x-apple-reminder://UUID`), which always produced `x-apple-` — completely useless
- Fixed both functions to `strings.TrimPrefix(id, "x-apple-reminder://")` before truncating to 8 chars
- Now displays meaningful UUID prefixes like `6ECEA745`, `E24435D3`, etc.

### Fixed: GetReminder Performance (reminders.go)
- `app.reminders.byId()` takes **10-17 seconds** from Go's `exec.Command` — catastrophically slow
- Replaced with bulk property access approach: iterate lists, fetch just IDs first (fast), then bulk-fetch all properties only from the list containing the target
- New implementation also supports **prefix matching** directly in JXA — compares user's short ID against the UUID portion of each reminder
- Single JXA call, stops at first match via `break`

### Simplified: findReminderByID (show.go)
- Old implementation: try `GetReminder` → on failure, call `ListReminders(nil)` (fetches ALL 123 reminders) → prefix match in Go
- New implementation: just calls `GetReminder` which handles prefix matching internally in JXA
- Removed expensive `ListReminders(nil)` fallback that was the real cause of the hang

## Key Insights

### Go exec.Command vs Terminal osascript Performance
Critical discovery: `osascript` called from Go's `exec.Command` is **dramatically slower** than from the terminal:
- Terminal: `app.reminders.byId()` = <1s
- Go exec: `app.reminders.byId()` = 10-17s
- Terminal: bulk list all = ~1s
- Go exec: bulk list all = ~20s (still faster than byId!)
- Go exec: `app.lists.name()` = 0.4s (minimum overhead)

Each `exec.Command("osascript", ...)` has ~0.4s minimum overhead. For 4 lists x 11 property arrays, that's still only 1 osascript call, but the JXA runtime itself is slower when launched as a subprocess.

### What Failed
- Initial assumption that `rem list` was completely broken — it actually worked, just needed >60s for 123 reminders across 4 lists
- The real blocker was `GetReminder` using `byId()` which is O(all reminders) in the Reminders app

### Performance Profile (from Go exec.Command)
| Operation | Time |
|-----------|------|
| `app.lists.name()` | 0.4s |
| `list.reminders.length` (single list) | 1.3s |
| `list.reminders.id()` bulk (8 items) | 3.3s |
| `app.reminders.byId()` | 10-17s |
| All lists, all properties (123 items) | ~60s |

## Decisions Made
- **Removed `byId()` entirely** — too slow from Go subprocess. Bulk access per-list is always faster.
- **Prefix matching in JXA** — moved from Go-side to JXA-side to avoid the expensive `ListReminders(nil)` fallback
- **Case-insensitive matching** — `toUpperCase()` comparison so users can type lowercase IDs

## All Commands Verified Working
`version`, `lists`, `list`, `ls`, `show`, `get`, `add`, `update`, `complete`, `uncomplete`, `flag`, `unflag`, `delete`, `search`, `stats`, `overdue`, `upcoming`, `export` (json/csv), `import` (dry-run), `list-mgmt` (create/rename/delete), `completion` (bash/zsh/fish), `--no-color`

---

## Session 3 - EventKit Migration: 100-500x Read Speedup

## Goal
Eliminate the catastrophic slowness of all read commands. Even `rem lists` (just list names) took 8.3s. `rem list` with filters took 42-60s. Replace JXA/osascript reads with something fundamentally faster.

## What Changed

### New: Compiled Swift EventKit Helper (`internal/swift/helper.swift`)
- Built a ~100KB compiled Swift binary using the EventKit framework for all reads
- Subcommands: `lists`, `reminders` (with `--list`, `--completed`, `--search`, `--due-before`, `--due-after` filters), `get <id>`
- Returns JSON, parsed by Go layer
- Compiled with `swiftc -O`, placed at `bin/reminders-helper`
- Go executor finds it via `os.Executable()` dir (next to `bin/rem`) or `PATH`

### Rewrote: `executor.go` — Added `RunHelper()` method
- `findHelperPath()` resolves helper binary location
- `RunHelper(args...)` executes with 30s timeout, captures stdout/stderr
- Existing `Run()` (AppleScript) and `RunJXA()` preserved for writes and flagged fallback

### Rewrote: `lists.go` — All reads via helper
- `GetLists()` now calls `RunHelper("lists")` instead of JXA `.map(l => l.properties())`
- `GetList(name)` filters from `GetLists()` result instead of separate JXA call
- Writes (Create/Rename/Delete) still use AppleScript — unchanged

### Rewrote: `reminders.go` — All reads via helper
- `ListReminders(filter)` builds helper args from filter, calls `RunHelper("reminders", ...)`
- `GetReminder(id)` calls `RunHelper("get", id)` — supports full ID, UUID, and prefix
- Replaced `jxaReminder`/`jxaBulkResult` types with `helperReminder` type
- `fetchFlaggedIDs()` — new JXA-only function, called exclusively when `--flagged` filter is active (EventKit can't expose flagged)

### Updated: `Makefile`
- `build-helper` target: `swiftc -O -o bin/reminders-helper internal/swift/helper.swift`
- `build` depends on `build-helper` — both binaries built together
- `install` copies helper to `$GOPATH/bin`

### Updated: `CLAUDE.md` and `MEMORY.md`
- Architecture docs reflect Swift EventKit helper as the read layer
- JXA/AppleScript rules replaced with EventKit rules

## Key Insights

### Why JXA was fundamentally slow
Each JXA bulk `.property()` call = one Apple Event = ~3.5s per property per list (for 90 items). Cost formula: `~2s base + ~3.5s × num_properties`. For 11 properties across 4 lists in a single `osascript` call = ~42s. This is an IPC bottleneck — the Reminders.app processes Apple Events serially.

### Concurrency doesn't help with Apple Events
Tested parallel `osascript` processes fetching different properties from the same list: 23s total vs 22s sequential. Tested parallel per-list fetches: 34s vs 35.6s. The Reminders app serializes all incoming Apple Events regardless of source process.

### EventKit bypasses the bottleneck entirely
EventKit is an in-process framework — no IPC, no Apple Events, no serialization. Direct memory access to the reminder store. Result: ALL 224 reminders with ALL properties in 0.17s.

### EventKit sees more data than JXA
JXA found 4 lists (local default account only). EventKit found 12 lists (including iCloud-synced accounts like "Bucket List", "travel", "watch", "Dreams" lists). This is strictly better.

### EventKit limitation: no `flagged` property
`EKReminder` has no `isFlagged` or `flagged` member. Attempted `value(forKey: "flagged")` — crashes with `NSUnknownKeyException`. Solution: JXA fallback only when `--flagged` filter is active. This is the only remaining slow path.

### Swift compilation is fast enough
`swiftc -O` compiles the helper in ~2.5s. The output is ~100KB. This runs once at build time, not at runtime.

### ID compatibility
EventKit's `calendarItemIdentifier` = same UUID as in `x-apple-reminder://UUID`. Just prepend the prefix for AppleScript write compatibility. Verified by comparing IDs across both systems.

## What Failed
- **`r.isFlagged` in Swift** — doesn't exist on `EKReminder`. EventKit simply doesn't model this property.
- **`value(forKey: "flagged")`** — crashes with NSUnknownKeyException, not KVC-compliant.
- **Concurrent osascript** — Reminders.app serializes Apple Events internally, no speedup.

## Performance Results (benchmark.sh, 3 runs each, min time)

| Command | Before (JXA) | After (EventKit) | Speedup |
|---------|-------------|-------------------|---------|
| `lists` | 8.3s | 0.12s | **69x** |
| `lists --count` | 8.3s | 0.12s | **69x** |
| `list` (all 224) | ~60s | 0.13s | **462x** |
| `list --list Inbox` | ~22s | 0.10s | **220x** |
| `list --incomplete` | ~42s | 0.11s | **382x** |
| `show` (prefix) | ~5s | 0.11s | **45x** |
| `search` | ~60s | 0.11s | **545x** |
| `stats` | ~68s | 0.23s | **296x** |
| `overdue` | ~60s | 0.12s | **500x** |
| `upcoming` | ~60s | 0.12s | **500x** |
| `export json` | ~60s | 0.12s | **500x** |

All commands now complete in **<250ms**.

## Decisions Made
- **EventKit for all reads, AppleScript for writes** — clean separation. EventKit is 100-500x faster. AppleScript write syntax is simpler than EventKit's save/commit model.
- **Flagged as JXA fallback only** — acceptable tradeoff. `--flagged` is rarely used. All other reads are instant.
- **Helper binary next to Go binary** — `os.Executable()` dir lookup means no PATH dependency for normal `make build` usage.
- **No per-command field optimization needed** — EventKit returns all properties in 0.17s anyway. No need to fetch minimal fields.

---
